name: Deploy service

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        type: choice
        options:
          - flatwhite
  workflow_call:
    inputs:
      environment:
        required: true
        type: string

jobs:
  validate-environment:
    name: Validate requested environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.validate.outputs.environment }}
    steps:
      - name: Ensure environment exists
        id: validate
        env:
          REQUESTED_ENVIRONMENT: ${{ inputs.environment || github.event.inputs.environment }}
          GITHUB_TOKEN: ${{ github.token }}
          REPOSITORY: ${{ github.repository }}
        run: |
          if [ -z "$REQUESTED_ENVIRONMENT" ]; then
            echo "::error::No environment provided. Choose an environment before running the workflow."
            exit 1
          fi

          api_url="https://api.github.com/repos/$REPOSITORY/environments/$REQUESTED_ENVIRONMENT"
          status=$(curl -sS \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -o "$RUNNER_TEMP/environment.json" \
            -w '%{http_code}' \
            "$api_url")

          if [ "$status" -ne 200 ]; then
            if [ -f "$RUNNER_TEMP/environment.json" ]; then
              echo "::debug::$(cat "$RUNNER_TEMP/environment.json")"
            fi
            echo "::error::Environment '$REQUESTED_ENVIRONMENT' was not found in repository '$REPOSITORY'."
            exit 1
          fi

          echo "environment=$REQUESTED_ENVIRONMENT" >> "$GITHUB_OUTPUT"

  deploy:
    name: Deploy to remote server
    runs-on: ubuntu-latest
    needs: validate-environment
    environment: ${{ needs.validate-environment.outputs.environment }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      - name: Validate required secrets and variables
        env:
          HOST_SSH_PRIVATE_KEY: ${{ secrets.HOST_SSH_PRIVATE_KEY }}
          EMAIL: ${{ secrets.EMAIL }}
          UUID: ${{ secrets.UUID }}
          REMOTE_SERVER_IP_ADDRESS: ${{ vars.REMOTE_SERVER_IP_ADDRESS }}
          REMOTE_SERVER_USER: ${{ vars.REMOTE_SERVER_USER }}
          TARGET_DOMAIN_NAME: ${{ vars.TARGET_DOMAIN_NAME }}
        run: |
          missing=0
          check_required() {
            if [ -z "$1" ]; then
              echo "::error::Missing required $2"
              missing=1
            fi
          }

          check_required "$HOST_SSH_PRIVATE_KEY" "secret HOST_SSH_PRIVATE_KEY"
          check_required "$EMAIL" "secret EMAIL"
          check_required "$UUID" "secret UUID"
          check_required "$REMOTE_SERVER_IP_ADDRESS" "environment variable REMOTE_SERVER_IP_ADDRESS"
          check_required "$REMOTE_SERVER_USER" "environment variable REMOTE_SERVER_USER"
          check_required "$TARGET_DOMAIN_NAME" "environment variable TARGET_DOMAIN_NAME"

          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Configure SSH for Ansible
        env:
          SSH_PRIVATE_KEY: ${{ secrets.HOST_SSH_PRIVATE_KEY }}
          SSH_PUBLIC_KEY: ${{ secrets.HOST_SSH_PUBLIC_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if [ -n "$SSH_PUBLIC_KEY" ]; then
            echo "$SSH_PUBLIC_KEY" > ~/.ssh/id_rsa.pub
            chmod 644 ~/.ssh/id_rsa.pub
          fi
          ssh-keyscan -H "${{ vars.REMOTE_SERVER_IP_ADDRESS }}" >> ~/.ssh/known_hosts

      - name: Create dynamic inventory
        run: |
          printf '%s\n' \
            '[remote]' \
            'remote ansible_host=${{ vars.REMOTE_SERVER_IP_ADDRESS }} ansible_user=${{ vars.REMOTE_SERVER_USER }} ansible_ssh_private_key_file=~/.ssh/id_rsa ansible_python_interpreter=/usr/bin/python3 ansible_become=true ansible_become_method=sudo' \
            > ansible/inventory/remote.ini

      - name: Run Ansible playbook
        env:
          ANSIBLE_CONFIG: ansible.cfg
        run: |
          ansible-playbook -vv ansible/playbooks/site.yml \
            -i ansible/inventory/remote.ini \
            --extra-vars "xray_domain=${{ vars.TARGET_DOMAIN_NAME }} xray_email=${{ secrets.EMAIL }} xray_uuid=${{ secrets.UUID }}"

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa ~/.ssh/id_rsa.pub

      - name: Display client connection details
        if: success()
        env:
          XRAY_DOMAIN: ${{ vars.TARGET_DOMAIN_NAME }}
          XRAY_UUID: ${{ secrets.UUID }}
          XRAY_FLOW: xtls-rprx-vision
          XRAY_PORT: ${{ vars.XRAY_INBOUND_PORT }}
        run: |
          set -eo pipefail

          DOMAIN="${XRAY_DOMAIN}"
          UUID="${XRAY_UUID}"
          FLOW="${XRAY_FLOW}"
          PORT="${XRAY_PORT:-}"

          if [ -z "$PORT" ]; then
            PORT=443
          fi

          if [ -z "$DOMAIN" ] || [ -z "$UUID" ]; then
            echo "::error::Missing domain or UUID for generating client configuration."
            exit 1
          fi

          if ! command -v qrencode >/dev/null 2>&1; then
            echo "Installing qrencode for QR code output..."
            sudo apt-get update
            sudo apt-get install -y qrencode
          fi

          export CLIENT_NAME="Less Vision (${DOMAIN})"
          NAME_ENCODED=$(python -c "import os, urllib.parse; print(urllib.parse.quote(os.environ['CLIENT_NAME']))")

          ALPN_ENCODED="h2%2Chttp%2F1.1"

          SHADOWROCKET_URI="vless://${UUID}@${DOMAIN}:${PORT}?encryption=none&security=tls&type=tcp&flow=${FLOW}&sni=${DOMAIN}&alpn=${ALPN_ENCODED}#${NAME_ENCODED}"
          CLASH_META_URI="vless://${UUID}@${DOMAIN}:${PORT}?encryption=none&security=tls&type=tcp&flow=${FLOW}&sni=${DOMAIN}&alpn=${ALPN_ENCODED}&fp=chrome#${NAME_ENCODED}"

          CLASH_VERGE_BLOCK=$(printf '%s\n' \
            "- name: Less Vision (${DOMAIN})" \
            "  type: vless" \
            "  server: ${DOMAIN}" \
            "  port: ${PORT}" \
            "  uuid: ${UUID}" \
            "  cipher: none" \
            "  tls: true" \
            "  network: tcp" \
            "  flow: ${FLOW}" \
            "  udp: true" \
            "  servername: ${DOMAIN}" \
            "  alpn:" \
            "    - h2" \
            "    - http/1.1")

          print_qr_section() {
            local label="$1"
            local uri="$2"

            printf '\n%s\n' "$label"
            printf '%s\n\n' "$(printf '%*s' "${#label}" '' | tr ' ' '-')"
            printf '%s\n\n' "$uri"

            if command -v qrencode >/dev/null 2>&1; then
              qrencode -t ansiutf8 <<< "$uri"
              printf '\n'
            else
              echo "::warning::qrencode is not available; skipping QR code generation for $label."
            fi
          }

          printf '%s\n' \
            "============================================================" \
            "Client Configuration Summary" \
            "============================================================" \
            "" \
            "Shadowrocket (iOS)" \
            "------------------" \
            "${SHADOWROCKET_URI}" \
            "" \
            "Clash Meta (Android)" \
            "--------------------" \
            "${CLASH_META_URI}" \
            "" \
            "Clash Verge (macOS)" \
            "-------------------" \
            "${CLASH_VERGE_BLOCK}"

          print_qr_section "Shadowrocket (iOS) QR" "$SHADOWROCKET_URI"
          print_qr_section "Clash Meta (Android) QR" "$CLASH_META_URI"
