name: Deploy service
run-name: >-
  Deploy ${{ github.event.inputs.environment || inputs.environment || 'environment' }}
  to ${{ github.event.inputs.target_domain_name || inputs.target_domain_name || 'domain' }}

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        type: environment
      target_domain_name:
        description: "Target domain name for the deployment"
        required: true
        type: string
      remote_server_user:
        description: "SSH user for the remote server"
        required: true
        type: string
      remote_server_ip_address:
        description: "IP address of the remote server"
        required: true
        type: string
      uuid:
        description: "Optional XRAY UUID override (defaults to environment secret)"
        required: false
        type: string
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      target_domain_name:
        required: true
        type: string
      remote_server_user:
        required: true
        type: string
      remote_server_ip_address:
        required: true
        type: string
      uuid:
        required: false
        type: string

jobs:
  validate-environment:
    name: Validate requested environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.validate.outputs.environment }}
      target_domain_name: ${{ steps.collect.outputs.target_domain_name }}
      remote_server_user: ${{ steps.collect.outputs.remote_server_user }}
      remote_server_ip_address: ${{ steps.collect.outputs.remote_server_ip_address }}
      uuid: ${{ steps.collect.outputs.uuid }}
    steps:
      - name: Ensure environment exists
        id: validate
        env:
          REQUESTED_ENVIRONMENT: ${{ inputs.environment || github.event.inputs.environment }}
          GITHUB_TOKEN: ${{ github.token }}
          REPOSITORY: ${{ github.repository }}
        run: |
          if [ -z "$REQUESTED_ENVIRONMENT" ]; then
            echo "::error::No environment provided. Choose an environment before running the workflow."
            exit 1
          fi

          api_url="https://api.github.com/repos/$REPOSITORY/environments/$REQUESTED_ENVIRONMENT"
          status=$(curl -sS \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -o "$RUNNER_TEMP/environment.json" \
            -w '%{http_code}' \
            "$api_url")

          if [ "$status" -ne 200 ]; then
            if [ -f "$RUNNER_TEMP/environment.json" ]; then
              echo "::debug::$(cat "$RUNNER_TEMP/environment.json")"
            fi
            echo "::error::Environment '$REQUESTED_ENVIRONMENT' was not found in repository '$REPOSITORY'."
            exit 1
          fi

          echo "environment=$REQUESTED_ENVIRONMENT" >> "$GITHUB_OUTPUT"

      - name: Collect deployment parameters
        id: collect
        env:
          TARGET_DOMAIN_NAME_INPUT: ${{ inputs.target_domain_name || github.event.inputs.target_domain_name }}
          REMOTE_SERVER_USER_INPUT: ${{ inputs.remote_server_user || github.event.inputs.remote_server_user }}
          REMOTE_SERVER_IP_ADDRESS_INPUT: ${{ inputs.remote_server_ip_address || github.event.inputs.remote_server_ip_address }}
          UUID_INPUT: ${{ inputs.uuid || github.event.inputs.uuid }}
          SECRET_UUID: ${{ secrets.UUID }}
        run: |
          set -euo pipefail

          target_domain_name="${TARGET_DOMAIN_NAME_INPUT:-}"
          remote_server_user="${REMOTE_SERVER_USER_INPUT:-}"
          remote_server_ip_address="${REMOTE_SERVER_IP_ADDRESS_INPUT:-}"
          uuid_input="${UUID_INPUT:-}"
          secret_uuid="${SECRET_UUID:-}"

          missing=0

          check_required() {
            if [ -z "$1" ]; then
              echo "::error::Missing required $2"
              missing=1
            fi
          }

          check_required "$target_domain_name" "input TARGET_DOMAIN_NAME"
          check_required "$remote_server_user" "input REMOTE_SERVER_USER"
          check_required "$remote_server_ip_address" "input REMOTE_SERVER_IP_ADDRESS"

          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

          if [ -n "$uuid_input" ]; then
            uuid_value="$uuid_input"
          elif [ -n "$secret_uuid" ]; then
            uuid_value="$secret_uuid"
          else
            echo "::error::UUID input not provided and environment secret UUID is unavailable."
            exit 1
          fi

          {
            echo "target_domain_name=$target_domain_name"
            echo "remote_server_user=$remote_server_user"
            echo "remote_server_ip_address=$remote_server_ip_address"
            echo "uuid=$uuid_value"
          } >> "$GITHUB_OUTPUT"

  deploy:
    name: Deploy to remote server
    runs-on: ubuntu-latest
    needs: validate-environment
    environment: ${{ needs.validate-environment.outputs.environment }}
    env:
      TARGET_DOMAIN_NAME: ${{ needs.validate-environment.outputs.target_domain_name }}
      REMOTE_SERVER_USER: ${{ needs.validate-environment.outputs.remote_server_user }}
      REMOTE_SERVER_IP_ADDRESS: ${{ needs.validate-environment.outputs.remote_server_ip_address }}
      XRAY_UUID: ${{ needs.validate-environment.outputs.uuid }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Update workflow run name
        env:
          GITHUB_TOKEN: ${{ github.token }}
          REPOSITORY: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          DEPLOY_ENVIRONMENT: ${{ needs.validate-environment.outputs.environment }}
          TARGET_DOMAIN_NAME: ${{ needs.validate-environment.outputs.target_domain_name }}
          REMOTE_SERVER_IP_ADDRESS: ${{ needs.validate-environment.outputs.remote_server_ip_address }}
        run: |
          python - <<'PY'
          import json
          import os
          import urllib.request
          from datetime import datetime, timedelta, timezone

          tz = timezone(timedelta(hours=8), name="CST")
          timestamp = datetime.now(tz).strftime("%Y-%m-%d %H:%M:%S %Z")

          environment = os.environ.get("DEPLOY_ENVIRONMENT") or "unknown"
          domain = os.environ.get("TARGET_DOMAIN_NAME") or "unknown"
          ip_address = os.environ.get("REMOTE_SERVER_IP_ADDRESS") or "unknown"

          run_name = f"Deploy {environment} -> {domain} ({ip_address}) at {timestamp}"

          url = f"https://api.github.com/repos/{os.environ['REPOSITORY']}/actions/runs/{os.environ['RUN_ID']}"
          data = json.dumps({"name": run_name}).encode()

          request = urllib.request.Request(url, data=data, method="PATCH")
          request.add_header("Authorization", f"Bearer {os.environ['GITHUB_TOKEN']}")
          request.add_header("Accept", "application/vnd.github+json")

          with urllib.request.urlopen(request) as response:
            response.read()
          PY

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      - name: Validate required secrets and variables
        env:
          HOST_SSH_PRIVATE_KEY: ${{ secrets.HOST_SSH_PRIVATE_KEY }}
          EMAIL: ${{ secrets.EMAIL }}
          UUID: ${{ needs.validate-environment.outputs.uuid }}
          REMOTE_SERVER_IP_ADDRESS: ${{ needs.validate-environment.outputs.remote_server_ip_address }}
          REMOTE_SERVER_USER: ${{ needs.validate-environment.outputs.remote_server_user }}
          TARGET_DOMAIN_NAME: ${{ needs.validate-environment.outputs.target_domain_name }}
        run: |
          missing=0
          check_required() {
            if [ -z "$1" ]; then
              echo "::error::Missing required $2"
              missing=1
            fi
          }

          check_required "$HOST_SSH_PRIVATE_KEY" "secret HOST_SSH_PRIVATE_KEY"
          check_required "$EMAIL" "secret EMAIL"
          check_required "$UUID" "deployment UUID value"
          check_required "$REMOTE_SERVER_IP_ADDRESS" "deployment remote server IP address"
          check_required "$REMOTE_SERVER_USER" "deployment remote server user"
          check_required "$TARGET_DOMAIN_NAME" "deployment target domain name"

          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Configure SSH for Ansible
        env:
          SSH_PRIVATE_KEY: ${{ secrets.HOST_SSH_PRIVATE_KEY }}
          SSH_PUBLIC_KEY: ${{ secrets.HOST_SSH_PUBLIC_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if [ -n "$SSH_PUBLIC_KEY" ]; then
            echo "$SSH_PUBLIC_KEY" > ~/.ssh/id_rsa.pub
            chmod 644 ~/.ssh/id_rsa.pub
          fi
          ssh-keyscan -H "$REMOTE_SERVER_IP_ADDRESS" >> ~/.ssh/known_hosts

      - name: Create dynamic inventory
        run: |
          set -euo pipefail

          mkdir -p ansible/inventory

          printf '%s\n' \
            '[remote]' \
            "remote ansible_host=${REMOTE_SERVER_IP_ADDRESS} ansible_user=${REMOTE_SERVER_USER} ansible_ssh_private_key_file=~/.ssh/id_rsa ansible_python_interpreter=/usr/bin/python3 ansible_become=true ansible_become_method=sudo" \
            > ansible/inventory/remote.ini

      - name: Run Ansible playbook
        env:
          ANSIBLE_CONFIG: ansible.cfg
        run: |
          ansible-playbook -vv ansible/playbooks/site.yml \
            -i ansible/inventory/remote.ini \
            --extra-vars "xray_domain=$TARGET_DOMAIN_NAME xray_email=${{ secrets.EMAIL }} xray_uuid=$XRAY_UUID"

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa ~/.ssh/id_rsa.pub

      - name: Display client connection details
        if: success()
        env:
          XRAY_DOMAIN: ${{ env.TARGET_DOMAIN_NAME }}
          XRAY_UUID: ${{ env.XRAY_UUID }}
          XRAY_FLOW: xtls-rprx-vision
          XRAY_PORT: ${{ vars.XRAY_INBOUND_PORT }}
        run: |
          set -eo pipefail

          DOMAIN="$(printf '%s' "${XRAY_DOMAIN}")"
          UUID="$(printf '%s' "${XRAY_UUID}")"
          FLOW="${XRAY_FLOW}"
          PORT="${XRAY_PORT:-}"

          if [ -z "$PORT" ]; then
            PORT=443
          fi

          if [ -z "$DOMAIN" ] || [ -z "$UUID" ]; then
            echo "::error::Missing domain or UUID for generating client configuration."
            exit 1
          fi

          if ! command -v qrencode >/dev/null 2>&1; then
            echo "Installing qrencode for QR code output..."
            sudo apt-get update
            sudo apt-get install -y qrencode
          fi

          export CLIENT_NAME="Less Vision (${DOMAIN})"
          NAME_ENCODED=$(python -c "import os, urllib.parse; print(urllib.parse.quote(os.environ['CLIENT_NAME']))")

          ALPN_ENCODED="h2%2Chttp%2F1.1"

          SHADOWROCKET_URI="vless://${UUID}@${DOMAIN}:${PORT}?encryption=none&security=tls&type=tcp&flow=${FLOW}&sni=${DOMAIN}&alpn=${ALPN_ENCODED}#${NAME_ENCODED}"
          CLASH_META_URI="vless://${UUID}@${DOMAIN}:${PORT}?encryption=none&security=tls&type=tcp&flow=${FLOW}&sni=${DOMAIN}&alpn=${ALPN_ENCODED}&fp=chrome#${NAME_ENCODED}"

          CLASH_VERGE_BLOCK=$(printf '%s\n' \
            "- name: Less Vision (${DOMAIN})" \
            "  type: vless" \
            "  server: ${DOMAIN}" \
            "  port: ${PORT}" \
            "  uuid: ${UUID}" \
            "  cipher: none" \
            "  tls: true" \
            "  network: tcp" \
            "  flow: ${FLOW}" \
            "  udp: true" \
            "  servername: ${DOMAIN}" \
            "  alpn:" \
            "    - h2" \
            "    - http/1.1")

          print_qr_section() {
            local label="$1"
            local uri="$2"

            printf '\n%s\n' "$label"
            printf '%s\n\n' "$(printf '%*s' "${#label}" '' | tr ' ' '-')"
            printf '%s\n\n' "$uri"

            if command -v qrencode >/dev/null 2>&1; then
              qrencode -t ansiutf8 <<< "$uri"
              printf '\n'
            else
              echo "::warning::qrencode is not available; skipping QR code generation for $label."
            fi
          }

          printf '%s\n' \
            "============================================================" \
            "Client Configuration Summary" \
            "============================================================" \
            "" \
            "Shadowrocket (iOS)" \
            "------------------" \
            "${SHADOWROCKET_URI}" \
            "" \
            "Clash Meta (Android)" \
            "--------------------" \
            "${CLASH_META_URI}" \
            "" \
            "Clash Verge (macOS)" \
            "-------------------" \
            "${CLASH_VERGE_BLOCK}"

          print_qr_section "Shadowrocket (iOS) QR" "$SHADOWROCKET_URI"
          print_qr_section "Clash Meta (Android) QR" "$CLASH_META_URI"
